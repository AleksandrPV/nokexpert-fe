---
description:  Enforces Angular 20 conventions, TypeScript standards, and Tailwind CSS utility classes for a modular frontend application globs: ["src/app//*.component.ts", "src/app//.component.html", "src/app/**/.component.css"] 
globs:
alwaysApply: true
---

Use TypeScript with strict type checking for all files.
Create standalone Angular components by default, using the standalone: true property.
Use Angular signals for reactive state management when applicable.
Follow Angular naming conventions: suffix component files with .component.ts, .component.html, and .component.css.
Use PascalCase for component class names and kebab-case for component selectors (e.g., app-user-list).
Generate JSDoc comments for all public methods and properties in components.
Use Tailwind CSS utility classes in component templates; avoid inline styles unless explicitly required.
Ensure Tailwind classes respect Angular’s ViewEncapsulation (default: Emulated) to prevent style leaks.
Organize Tailwind classes by category (e.g., layout, spacing, typography) for readability, following the recommended order: https://tailwindcss.com/docs/optimizing-for-production#class-order.
When generating HTTP services, use Angular’s HttpClient with typed responses and error handling.
Example standalone Angular component with Tailwind CSS:

import { Component, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { HttpClient } from '@angular/common/http';
import { catchError, throwError } from 'rxjs';

/** Displays a list of users with Tailwind styling */
@Component({
  selector: 'app-user-list',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="container mx-auto p-4">
      <h1 class="text-2xl font-bold mb-4">User List</h1>
      <ul class="space-y-2">
        <li *ngFor="let user of users()" class="p-2 bg-gray-100 rounded hover:bg-gray-200">
          {{ user.name }}
        </li>
      </ul>
    </div>
  `,
  styles: []
})
export class UserListComponent {
  /** Signal to store user list */
  users = signal<{ name: string }[]>([]);

  constructor(private http: HttpClient) {
    this.fetchUsers();
  }

  /** Fetches users from the backend */
  fetchUsers() {
    this.http.get<{ name: string }[]>('/api/users')
      .pipe(
        catchError(error => {
          console.error('Error fetching users', error);
          return throwError(() => new Error('Failed to fetch users'));
        })
      )
      .subscribe(users => this.users.set(users));
  }
}
Example Tailwind configuration in tailwind.config.js:
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ['./src/**/*.{html,ts}'],
  theme: {
    extend: {
      colors: {
        primary: '#1D4ED8',
      },
    },
  },
  plugins: [],
};

When generating templates, use Tailwind classes for layout, spacing, and typography (e.g., flex, mx-auto, text-2xl).
Avoid duplicating Tailwind classes; use @apply in .component.css files only for reusable styles, e.g.:
.btn {
  @apply px-4 py-2 bg-primary text-white rounded hover:bg-blue-700;
}

When generating services, use Angular’s dependency injection and RxJS for HTTP requests.
Always reference this file (angular-tailwind.rules) when generating or editing code.

